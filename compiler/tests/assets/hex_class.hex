# HEX Programming Language
# Copyright (C) 2013  Yanzheng Li
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, version 3 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


# This is a test file used for the HEX compiler.
# Tests class declarations.


class Person {

  name: null
  age: null
  country: null
  gender: 'male'
  hobbies: []
  skills: []

  __init__: (name, age) => {
    self.name = name;
    self.age = age;
  }

  hello: () => {
    print("Hello, my name is @name, I'm @age and I'm from @country");
  }

  set_age: (age) => {
    return if age < 0;
    self.age = age;
  }
} 


class Student extends Person {

  grade: 8
  school: null
  courses: {}
  grades: {}

  enroll: (course) => {
    desired_course = school.courses.find(course);
    if desired_course and desired_course.grade <= self.grade {
      self.courses[desired_course.code] = desired_course;
    }
  }

  drop: (course) => {
    desired_course = school.courses.find(course);
    if desired_course and len(courses)-1 >= school.MIN_COURSES {
      self.courses[desired_course.code] = null;
    }
  }
}


class School {

  name: null
  courses: []

}


class Course {

  name: null
  code: null
  grade: 7
}

@nothing
class ComplexNum {

  real: 0
  imag: 0

  __init__: (real, imag) => {
    self.real = real;
    self.imag = imag;
  }

  __eq__: (num) -> real == num.real and imag == num.imag

  __str__: () -> str(real) + '+' + str(imag) + 'i'

  abs: () -> math.sqrt(real**2 + imag**2)

  operator +: (num) => {
    real+=num.real;
    imag+=num.imag;
  }

  operator -: (num) => {
    real-=num.real;
    imag-=num.imag;
  }

  conjugate: () -> imag *= -1

  normalize: () => {
    d = self.abs();
    real = real/d;
    imag = imag/d;
  }
}
